import require$$0 from "react";
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var PropTypes = propTypes.exports;
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = require$$0, g = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if (typeof Symbol === "function" && Symbol.for) {
  var h = Symbol.for;
  g = h("react.element");
  reactJsxRuntime_production_min.Fragment = h("react.fragment");
}
var m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, k) {
  var b, d = {}, e = null, l = null;
  k !== void 0 && (e = "" + k);
  a.key !== void 0 && (e = "" + a.key);
  a.ref !== void 0 && (l = a.ref);
  for (b in a)
    n.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      d[b] === void 0 && (d[b] = a[b]);
  return { $$typeof: g, type: c, key: e, ref: l, props: d, _owner: m.current };
}
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
const getMatches = (str, searchString, global, caseSensitive) => {
  const flags = caseSensitive ? "g" : "gi";
  const regex = new RegExp(escapeStringRegexp(searchString), flags);
  const matches = [...str.matchAll(regex)].map((a) => [a.index, a.index + searchString.length]);
  return global ? matches : matches.length ? [matches[0]] : [];
};
const getDividers = (str, separator, global, caseSensitive) => {
  const flags = caseSensitive ? "g" : "gi";
  const regex = new RegExp(escapeStringRegexp(separator), flags);
  const dividers = [...str.matchAll(regex)].map((a) => a.index + separator.length);
  return [...global ? dividers : dividers.length ? [dividers[0]] : [], str.length];
};
const isMatchingChar = (index, matches) => {
  return matches.reduce((prev, match) => {
    return prev || index >= match[0] && index < match[1];
  }, false);
};
function SplitMatch(props) {
  const {
    caseSensitiveMatch = false,
    caseSensitiveSplit = false,
    globalMatch = true,
    globalSplit = true,
    includeSeparator = true,
    searchText = "",
    separator = ",",
    children: text,
    MatchComponent,
    SplitComponent
  } = props;
  if (!text)
    return null;
  const wrapMatch = (match, key) => {
    if (MatchComponent)
      return /* @__PURE__ */ jsx(MatchComponent, {
        children: match
      }, key);
    return /* @__PURE__ */ jsx("strong", {
      children: match
    }, key);
  };
  const wrapSplit = (children, key, index) => {
    if (SplitComponent)
      return /* @__PURE__ */ jsx(SplitComponent, {
        index,
        children
      }, key);
    return /* @__PURE__ */ jsx("span", {
      children
    }, key);
  };
  let separatorRemoved = false;
  const dividers = getDividers(text, separator, globalSplit, caseSensitiveSplit);
  const matches = getMatches(text, searchText, globalMatch, caseSensitiveMatch);
  const parts = dividers.map((dividerIndex, i) => {
    let tag = "";
    let tagIsMatch = false;
    const parts2 = [];
    const prevIndex = dividers[i - 1] || 0;
    const chars = Array.from(text.substring(prevIndex, dividerIndex));
    const addTag = (isMatch, finalTagInDivider) => {
      const key = `part-${i}-${parts2.length}`;
      if (tag.length && tagIsMatch !== isMatch) {
        if (!includeSeparator && finalTagInDivider && (globalSplit || !separatorRemoved)) {
          tag = tag.replace(separator, "");
          separatorRemoved = true;
        }
        parts2.push(tagIsMatch ? wrapMatch(tag, key) : /* @__PURE__ */ jsx(require$$0.Fragment, {
          children: tag
        }, key));
        tag = "";
      }
    };
    chars.forEach((char, index) => {
      const isMatch = isMatchingChar(prevIndex + index, matches);
      addTag(isMatch);
      tagIsMatch = isMatch;
      tag = `${tag}${char}`;
    });
    addTag(!tagIsMatch, true);
    return wrapSplit(parts2, `part-${i}`, i);
  });
  return parts;
}
SplitMatch.propTypes = {
  caseSensitiveMatch: PropTypes.bool,
  caseSensitiveSplit: PropTypes.bool,
  children: PropTypes.string,
  globalMatch: PropTypes.bool,
  globalSplit: PropTypes.bool,
  includeSeparator: PropTypes.bool,
  searchText: PropTypes.string,
  separator: PropTypes.string,
  MatchComponent: PropTypes.elementType,
  SplitComponent: PropTypes.elementType
};
export { SplitMatch as default };
